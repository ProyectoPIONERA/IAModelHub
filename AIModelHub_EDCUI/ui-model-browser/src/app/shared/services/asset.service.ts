/**
 * EDC REST API
 * EDC REST APIs - merged by OpenApiMerger
 *
 * The version of the OpenAPI document: 0.0.1-SNAPSHOT
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { Injectable, inject } from '@angular/core';
import { HttpClient, HttpHeaders } from '@angular/common/http';
import { Observable, from, lastValueFrom } from 'rxjs';

import { expandArray, Asset, EDC_CONTEXT, JSON_LD_DEFAULT_CONTEXT } from '@think-it-labs/edc-connector-client';
import { AssetInput, QuerySpec } from '@think-it-labs/edc-connector-client';
import { environment } from '../../../environments/environment';
import { CONTEXTS } from '../utils/app.constants';

@Injectable({
  providedIn: 'root'
})
export class AssetService {
  private readonly http = inject(HttpClient);

  private readonly BASE_URL = `${environment.runtime.managementApiUrl}${environment.runtime.service.asset.baseUrl}`;
  private readonly UPLOAD_CHUNK_URL = `${environment.runtime.managementApiUrl}${environment.runtime.service.asset.uploadChunk}`;
  private readonly FINALIZE_UPLOAD_URL = `${environment.runtime.managementApiUrl}${environment.runtime.service.asset.finalizeUpload}`;

  /**
   * Helper method to transform frontend properties to EDC backend format
   * @param properties Frontend properties object
   * @returns EDC-compatible properties with 'asset:prop:' prefixes
   */
  private transformPropertiesToEDC(properties: any): any {
    const edcProperties: any = {
      'asset:prop:name': properties['name'] || 'Untitled Asset',
      'asset:prop:version': properties['version'] || '1.0',
      'asset:prop:contenttype': properties['contenttype'] || 'application/octet-stream',
      'asset:prop:type': properties['assetType'] || 'MLModel',
      'asset:prop:description': properties['dcterms:description'] || properties['shortDescription'] || '',
      'asset:prop:shortDescription': properties['shortDescription'] || '',
      'dcat:keyword': properties['dcat:keyword'] || []
    };
    
    // Add optional fields if present
    if (properties['dcat:byteSize']) {
      edcProperties['asset:prop:byteSize'] = properties['dcat:byteSize'];
    }
    if (properties['dcterms:format']) {
      edcProperties['asset:prop:format'] = properties['dcterms:format'];
    }
    
    return edcProperties;
  }

  /**
   * Creates a new asset together with a data address
   * @param assetEntryDto
   */
  public createAsset(assetEntryDto: AssetInput): Observable<Record<string, unknown>> {
    // Extract ML metadata from properties if present
    const mlMetadata = assetEntryDto.properties['assetData']?.['mlMetadata'] || {};
    
    // Transform properties to EDC format
    const edcProperties = this.transformPropertiesToEDC(assetEntryDto.properties);
    
    // Build EDC-compatible payload
    const body = {
      "@context": {
        "@vocab": EDC_CONTEXT,
        "dcterms": CONTEXTS.dcterms,
        "dcat": CONTEXTS.dcat
      },
      "asset": {
        "@type": "Asset",
        "@id": assetEntryDto['@id'],
        "properties": edcProperties
      },
      "dataAddress": assetEntryDto.dataAddress
    }
    
    // Add ML metadata at root level if present
    if (mlMetadata && Object.keys(mlMetadata).length > 0) {
      (body as any).mlMetadata = mlMetadata;
    }

    return from(lastValueFrom(this.http.post<Asset>(
      `${this.BASE_URL}`, body
    )));
  }

  /**
   * Gets an asset with the given ID
   * @param id
   */
  public getAsset(id: string): Observable<Record<string, unknown>> {
    if (id === null || id === undefined) {
      throw new Error('Required parameter id was null or undefined when calling getAsset.');
    }

    return from(lastValueFrom(this.http.get<Asset>(
      `${this.BASE_URL}${environment.runtime.service.asset.get}${id}`
    )));
  }

  /**
   * Removes an asset with the given ID if possible. Deleting an asset is only possible if that asset is not yet referenced by a contract agreement, in which case an error is returned. DANGER ZONE: Note that deleting assets can have unexpected results, especially for contract offers that have been sent out or ongoing or contract negotiations.
   * @param id
   */
  public removeAsset(id: string): Observable<Record<string, unknown>> {
    if (id === null || id === undefined) {
      throw new Error('Required parameter id was null or undefined when calling removeAsset.');
    }

    return from(lastValueFrom(this.http.delete<Asset>(
      `${this.BASE_URL}${environment.runtime.service.asset.get}${id}`
    )));
  }

  /**
   * Gets all assets according to a particular query
   * @param querySpec
   */
  public requestAssets(querySpec?: QuerySpec): Observable<Asset[]> {
    let body;

    if (querySpec) {
      body = {
        ...querySpec,
        "@context": JSON_LD_DEFAULT_CONTEXT,
      }
    }

    return from(lastValueFrom(this.http.post<Asset[]>(
      `${this.BASE_URL}${environment.runtime.service.asset.getAll}`, body
    )).then(results => {
      return expandArray(results, () => new Asset());
    }));
  }

  /**
   * Gets the total number of assets
   */
  public count(): Observable<number> {
    const querySpec: QuerySpec = {
      filterExpression: []
    }

    const body = {
      "@context": JSON_LD_DEFAULT_CONTEXT,
      ...querySpec
    };

    return from(lastValueFrom(this.http.post<number>(
      `${environment.runtime.managementApiUrl}${environment.runtime.service.asset.count}`, body
    )));
  }

  /**
   * Initialize S3 upload session
   */
  async initUpload(assetId: string, fileName: string, totalChunks: number, contentType: string): Promise<{ sessionId: string; uploadId: string; s3Key: string }> {
    const body = {
      assetId,
      fileName,
      totalChunks,
      contentType
    };

    return await lastValueFrom(
      this.http.post<{ sessionId: string; uploadId: string; s3Key: string }>(`${this.UPLOAD_CHUNK_URL.replace('/upload-chunk', '/init-upload')}`, body)
    );
  }

  /**
   * Upload a chunk using S3 session-based API
   */
  async uploadChunk(sessionId: string, chunkNumber: number, chunk: Blob): Promise<{ etag: string }> {
    // Convert blob to base64
    const arrayBuffer = await chunk.arrayBuffer();
    const base64Data = btoa(
      new Uint8Array(arrayBuffer).reduce((data, byte) => data + String.fromCharCode(byte), '')
    );

    const body = {
      sessionId,
      chunkNumber,
      data: base64Data
    };

    return await lastValueFrom(
      this.http.post<{ etag: string }>(`${this.UPLOAD_CHUNK_URL}`, body)
    );
  }

  /**
   * Finalize S3 upload and create asset
   */
  async finalizeUpload(sessionId: string, parts: Array<{ PartNumber: number; ETag: string }>): Promise<{ success: boolean; s3Key: string; assetId: string }> {
    const body = {
      sessionId,
      parts
    };

    return await lastValueFrom(
      this.http.post<{ success: boolean; s3Key: string; assetId: string }>(`${this.FINALIZE_UPLOAD_URL}`, body)
    );
  }
}
